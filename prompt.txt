You are Google Antigravity acting as a senior full-stack engineer. Bootstrap a minimal but runnable monorepo scaffold in the CURRENT directory for:

AetherOS — AI-Integrated Web-Based Operating System Simulator (PRD v4)

SOURCE OF TRUTH
- Read and follow the PRD file in the current directory: "./AetherOS - PRD v4.pdf"
- Use the PRD to shape README content and feature scope.
- Build ONLY a “getting started” setup: scaffold, wiring, placeholders, and docs. No full OS simulator implementation yet.

GOALS
- Create two top-level folders inside the current directory:
  - ./client
  - ./server
- Make it runnable locally with minimal effort:
  - root: npm install
  - root: npm run dev (runs client + server)
- Use TypeScript end-to-end.
- Create clean docs: root README.md + client/README.md + server/README.md
- Provide .env.example files for both client and server.
- Keep dependencies minimal.

TECH CHOICES (simple, modern)
Client:
- Vite + React + TypeScript
- Tailwind CSS
- Zustand for state
- xterm.js for a “Terminal” window
- Web Worker as the “kernel simulation” placeholder

Server:
- Node.js + TypeScript + Fastify (preferred) OR Express (acceptable) — pick ONE and be consistent.
- Provide:
  - GET /health
  - POST /api/ai
- /api/ai must be safe-by-default:
  - reads OPENAI_API_KEY from env
  - if missing, return a helpful mocked response + setup guidance
  - if present, attempt a minimal OpenAI Responses-style request using fetch
  - if you’re not fully sure about the exact API format, keep the safe mock as fallback and leave TODOs, but keep the code structured for easy wiring later.
- Add:
  - CORS
  - basic in-memory rate limit middleware
  - request logging
  - centralized error handling

REPO STRUCTURE (create this)
/
  client/
    src/
      app/
      components/
      stores/
      worker/
      styles/
    index.html
    vite.config.ts
    tailwind.config.ts
    postcss.config.js
    package.json
    .env.example
    README.md
  server/
    src/
      index.ts
      routes/
      middleware/
      services/
      types/
    package.json
    tsconfig.json
    .env.example
    README.md
  docker-compose.yml
  package.json
  .gitignore
  README.md

CLIENT: MINIMUM UI REQUIREMENTS
Create a “desktop shell” page that demonstrates the concept without overbuilding:
- A taskbar (or top bar) with:
  - clock
  - fake CPU/RAM/Disk stats (from Zustand)
- A simple draggable window component
- Two windows shown by default:
  1) Terminal window (xterm.js)
     - supports stub commands:
       - help, clear, ps, kill <pid>, spawn <name>, mem, disk, about
     - commands operate on fake “kernel state” held in Zustand and/or fed by worker events
  2) Task Manager window
     - table of processes with pid, name, cpu%, memMB, status
- Add client/src/worker/kernel.worker.ts:
  - deterministic tick loop (10 ticks/sec is fine)
  - maintains kernel state: processes[], memory, disk
  - posts events to main thread:
    - TICK
    - PROCESS_SPAWNED
    - PROCESS_KILLED
  - main thread subscribes and updates Zustand

SERVER: MINIMUM REQUIREMENTS
- GET /health -> { ok: true, ts: ... }
- POST /api/ai:
  - input: { message: string, context?: any }
  - output: { reply: string, mode: "mock"|"live" }
- Keep responses stable and deterministic in mock mode.

ROOT DEV EXPERIENCE
- Use npm workspaces at root (preferred) OR a simple concurrently script.
- Root scripts:
  - dev (runs client + server)
  - build
  - lint (optional)
- Ensure README commands match your scripts exactly.

DOCKER (KEEP LIGHT)
- Provide a docker-compose.yml with postgres only (enough to indicate future Supabase/self-host DB direction).
- Don’t fully wire Supabase now unless it’s genuinely trivial; instead include a note in README:
  - “Supabase will be self-hosted later; currently we provide Postgres for local dev.”

DOCUMENTATION REQUIREMENTS
Root README.md must include:
- Executive summary aligned with PRD
- High-level architecture:
  - frontend desktop UI
  - kernel simulation in Web Worker
  - backend API
  - persistence plan (Supabase/Postgres)
  - AI assistant (server proxy)
  - CDN/deploy (Cloudflare; domain aetheros.necookie.dev)
- 80/20 feature list:
  - settings (planned)
  - file manager (planned)
  - CLI (stubbed now)
  - simple browser (planned; mention iframe approach)
  - task manager (stubbed now)
  - AI assistant (stubbed endpoint now)
- Tech stack list
- Security notes: keys stay server-side, rate limiting, CORS
- Local dev steps
- Environment variables
- Next steps checklist

Client README.md:
- setup, env vars, run commands

Server README.md:
- setup, env vars, run commands, endpoint examples (curl)

IMPLEMENTATION STEPS (DO THEM NOW)
1) Create folders/files listed above
2) Write code/configs so everything compiles and runs
3) Add sample .env.example in client and server
4) Add .gitignore and root scripts
5) Verify that “npm install && npm run dev” at root is consistent with what you created (no broken paths)

FINISH
At the end, print:
- A short file tree
- Exact commands to run
- A concise “Next steps” list

Proceed without asking me questions. If anything is ambiguous, pick the simplest reasonable option and document it in README.